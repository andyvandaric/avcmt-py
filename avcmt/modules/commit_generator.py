# Copyright 2025 Andy Vandaric
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# File: avcmt/modules/commit_generator.py
# FINAL REVISION: Refactored to pass linter complexity checks (C901, PLR0912).

import logging
import subprocess
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Any

from avcmt.ai import generate_with_ai
from avcmt.utils import (
    clean_ai_response,
    extract_commit_messages_from_md,
    get_jinja_env,
    is_recent_dry_run,
    setup_logging,
)


class CommitError(Exception):
    """Custom exception for failures during the commit generation process."""


class CommitGenerator:
    """Manages the AI-powered commit generation process."""

    def __init__(
        self,
        dry_run: bool = False,
        push: bool = False,
        debug: bool = False,
        force_rebuild: bool = False,
        provider: str = "pollinations",
        model: str = "gemini",
        logger: Any | None = None,
        **kwargs,
    ):
        self.dry_run = dry_run
        self.push = push
        self.debug = debug
        self.force_rebuild = force_rebuild
        self.provider = provider
        self.model = model
        self.logger = logger or setup_logging("log/commit.log")
        self.kwargs = kwargs
        self.dry_run_file = Path("log") / "commit_messages_dry_run.md"
        self.commit_template_env = get_jinja_env("commit")

    # --- Helper methods unchanged ---
    def _run_git_command(self, command: list[str]) -> str:
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                encoding="utf-8",
                errors="replace",
                check=True,
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            error_message = (
                f"Git command '{' '.join(e.cmd)}' failed: {e.stderr.strip()}"
            )
            self.logger.error(error_message)
            raise CommitError(error_message) from e

    def _get_changed_files(self) -> list[str]:
        output = self._run_git_command(
            [
                "git",
                "ls-files",
                "--deleted",
                "--modified",
                "--others",
                "--exclude-standard",
            ]
        )
        return [line.strip() for line in output.split("\n") if line.strip()]

    @staticmethod
    def _group_files_by_directory(files: list[str]) -> dict[str, list[str]]:
        grouped = defaultdict(list)
        for file_path in files:
            parent_dir = str(Path(file_path).parent)
            if parent_dir == ".":
                parent_dir = "root"
            grouped[parent_dir].append(file_path)
        return grouped

    def _get_diff_for_files(self, files: list[str]) -> str:
        return self._run_git_command(
            ["git", "--no-pager", "diff", "--staged", "--", *files]
        )

    def _write_dry_run_header(self):
        self.dry_run_file.parent.mkdir(parents=True, exist_ok=True)
        with self.dry_run_file.open("w", encoding="utf-8") as f:
            ts = datetime.now().astimezone().strftime("%Y-%m-%d %H:%M:%S (%Z)")
            f.write("# AI Semantic Release Commit Messages (Dry Run)\n")
            f.write(f"_Last generated: {ts}_\n\n")
            f.write("Automatically generated by `avcmt --dry-run`\n\n")

    def _write_dry_run_entry(self, group_name: str, commit_message: str):
        with self.dry_run_file.open("a", encoding="utf-8") as f:
            f.write(
                f"## Group: `{group_name}`\n\n```md\n{commit_message}\n```\n\n---\n\n"
            )

    def _stage_changes(self, files: list[str]):
        if not files:
            return
        self.logger.info(f"Staging files for group: {files}")
        self._run_git_command(["git", "add", *files])

    def _commit_changes(self, message: str):
        self.logger.info(f"Committing with message:\n{message}")
        self._run_git_command(["git", "commit", "-m", message])

    def _push_changes(self):
        self.logger.info("Pushing all commits to the active remote branch...")
        self._run_git_command(["git", "push"])
        self.logger.info("✔️ All changes pushed successfully.")

    def _get_commit_message(
        self, group_name: str, diff: str, cached_messages: dict
    ) -> str:
        if not self.force_rebuild and group_name in cached_messages:
            self.logger.info(f"[CACHED] Using cached message for {group_name}.")
            return cached_messages[group_name]
        if self.force_rebuild and group_name in cached_messages:
            self.logger.info(f"[FORCED] Ignoring cache for {group_name}.")
        template = self.commit_template_env.get_template("commit_message.j2")
        prompt = template.render(group_name=group_name, diff_text=diff)
        raw_message = generate_with_ai(
            prompt,
            provider=self.provider,
            model=self.model,
            debug=self.debug,
            **self.kwargs,
        )
        return clean_ai_response(raw_message)

    # --- REFACTOR: run() method is now a high-level orchestrator ---
    def run(self):
        """Main execution method, orchestrating the commit process."""
        initial_files = self._get_changed_files()
        if not initial_files:
            self.logger.info("No changed files detected. Exiting.")
            return

        grouped_files = self._group_files_by_directory(initial_files)
        cached_messages = self._prepare_cache()

        # --- BUG FIX: LINTER ERROR RUF059 ---
        # Replace 'successful_groups' with '_' as it's never used.
        _, failed_groups = self._process_groups(grouped_files, cached_messages)

        self._finalize_run(failed_groups)

    # --- REFACTOR: New helper for cache preparation ---
    def _prepare_cache(self) -> dict[str, str]:
        """Prepares the cache for a run, either by clearing or loading it."""
        if self.dry_run:
            self._write_dry_run_header()
            return {}

        if not self.force_rebuild and is_recent_dry_run(self.dry_run_file):
            self.logger.info(f"Recent cache found. Loading from {self.dry_run_file}")
            return extract_commit_messages_from_md(self.dry_run_file)

        return {}

    # --- REFACTOR: New helper for processing all groups ---
    def _process_groups(
        self, grouped_files: dict, cached_messages: dict
    ) -> tuple[list, list]:
        """Iterates through file groups and processes each one for committing."""
        successful_groups, failed_groups = [], []

        for group_name, files in grouped_files.items():
            was_successful = self._process_single_group(
                group_name, files, cached_messages
            )
            if was_successful:
                successful_groups.append(group_name)
            else:
                failed_groups.append(group_name)

        return successful_groups, failed_groups

    # --- REFACTOR: New helper for processing a single group ---
    def _process_single_group(
        self, group_name: str, files: list, cached_messages: dict
    ) -> bool:
        """Stages, generates a message for, and commits a single group of files."""
        self._stage_changes(files)

        diff = self._get_diff_for_files(files)
        if not diff.strip():
            self.logger.info(f"[SKIP] No diff for group {group_name}. Unstaging.")
            self._run_git_command(["git", "reset", "HEAD", "--", *files])
            return True  # Consider no-diff as a "success" for the run

        commit_message = self._get_commit_message(group_name, diff, cached_messages)

        if not commit_message:
            self.logger.error(f"Skipping group '{group_name}' due to empty message.")
            # Leave files staged for manual commit by the user
            return False

        if self.dry_run:
            self._write_dry_run_entry(group_name, commit_message)
            self._run_git_command(["git", "reset", "HEAD", "--", *files])
        else:
            self._commit_changes(commit_message)

        return True

    # --- REFACTOR: New helper for finalization (push and final logging) ---
    def _finalize_run(self, failed_groups: list):
        """Finalizes the run by pushing changes and logging completion status."""
        if self.push and not self.dry_run:
            if not failed_groups:
                self._push_changes()
            else:
                self.logger.error(
                    "❌ Push aborted because one or more commit groups failed."
                )

        if self.dry_run:
            self.logger.info(
                f"✅ DRY RUN COMPLETED. Review suggestions in: {self.dry_run_file.resolve()}"
            )
        else:
            self.logger.info("✅ Commit process completed.")
            if failed_groups:
                self.logger.warning(
                    f"The following groups were skipped: {', '.join(failed_groups)}"
                )
                self.logger.warning(
                    "Please review the changes, commit them manually, and then push."
                )


def run_commit_group_all(**kwargs):
    """Initializes and runs the CommitGenerator."""
    logger = logging.getLogger("avcmt")
    try:
        generator = CommitGenerator(**kwargs)
        generator.run()
    except (CommitError, Exception) as e:
        logger.error(f"FATAL: The commit process failed: {e}", exc_info=True)


__all__ = ["run_commit_group_all"]
