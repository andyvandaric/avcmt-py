# Copyright 2025 Andy Vandaric
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# File: avcmt/modules/commit_generator.py
# FINAL REVISION: Fixes staging logic to handle multi-group commits correctly.

import subprocess
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Any

from avcmt.ai import generate_with_ai
from avcmt.utils import (
    clean_ai_response,
    extract_commit_messages_from_md,
    get_jinja_env,
    is_recent_dry_run,
    setup_logging,
)


class CommitError(Exception):
    """Custom exception for failures during the commit generation process."""

    pass


class CommitGenerator:
    """Manages the AI-powered commit generation process."""

    def __init__(
        self,
        dry_run: bool = False,
        push: bool = False,
        debug: bool = False,
        force_rebuild: bool = False,
        provider: str = "pollinations",
        model: str = "gemini",
        logger: Any | None = None,
        **kwargs,
    ):
        self.dry_run = dry_run
        self.push = push
        self.debug = debug
        self.force_rebuild = force_rebuild
        self.provider = provider
        self.model = model
        self.logger = logger or setup_logging("log/commit.log")
        self.kwargs = kwargs
        self.dry_run_file = Path("log") / "commit_messages_dry_run.md"
        self.commit_template_env = get_jinja_env("commit")

    def _run_git_command(self, command: list[str]) -> str:
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                encoding="utf-8",
                errors="replace",
                check=True,
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            error_message = (
                f"Git command '{' '.join(e.cmd)}' failed: {e.stderr.strip()}"
            )
            self.logger.error(error_message)
            raise CommitError(error_message) from e

    def _get_changed_files(self) -> list[str]:
        output = self._run_git_command(
            [
                "git",
                "ls-files",
                "--deleted",
                "--modified",
                "--others",
                "--exclude-standard",
            ]
        )
        return [line.strip() for line in output.split("\n") if line.strip()]

    @staticmethod
    def _group_files_by_directory(files: list[str]) -> dict[str, list[str]]:
        grouped = defaultdict(list)
        for file_path in files:
            parent_dir = str(Path(file_path).parent)
            if parent_dir == ".":
                parent_dir = "root"
            grouped[parent_dir].append(file_path)
        return grouped

    def _get_diff_for_files(self, files: list[str]) -> str:
        return self._run_git_command(
            ["git", "--no-pager", "diff", "--staged", "--", *files]
        )

    def _write_dry_run_header(self):
        self.dry_run_file.parent.mkdir(parents=True, exist_ok=True)
        with self.dry_run_file.open("w", encoding="utf-8") as f:
            ts = datetime.now().astimezone().strftime("%Y-%m-%d %H:%M:%S (%Z)")
            f.write("# AI Semantic Release Commit Messages (Dry Run)\n")
            f.write(f"_Last generated: {ts}_\n\n")
            f.write("Automatically generated by `avcmt --dry-run`\n\n")

    def _write_dry_run_entry(self, group_name: str, commit_message: str):
        with self.dry_run_file.open("a", encoding="utf-8") as f:
            f.write(
                f"## Group: `{group_name}`\n\n```md\n{commit_message}\n```\n\n---\n\n"
            )

    def _stage_changes(self, files: list[str]):
        if not files:
            return
        self.logger.info(f"Staging files for group: {files}")
        self._run_git_command(["git", "add", *files])

    def _commit_changes(self, message: str):
        self.logger.info(f"Committing with message:\n{message}")
        self._run_git_command(["git", "commit", "-m", message])

    def _push_changes(self):
        self.logger.info("Pushing all commits to the active remote branch...")
        self._run_git_command(["git", "push"])
        self.logger.info("✔️ All changes pushed successfully.")

    def run(self):
        """Main execution method."""
        initial_files = self._get_changed_files()
        if not initial_files:
            self.logger.info("No changed files detected. Exiting.")
            return

        grouped_files = self._group_files_by_directory(initial_files)

        cached_messages = {}
        if self.dry_run:
            self._write_dry_run_header()
        elif not self.force_rebuild and is_recent_dry_run(self.dry_run_file):
            self.logger.info(f"Recent cache found. Loading from {self.dry_run_file}")
            cached_messages = extract_commit_messages_from_md(self.dry_run_file)

        # --- BUG FIX: Staging is now done inside the loop, per group ---
        for group_name, files in grouped_files.items():
            self._stage_changes(files)

            # Check for diff *after* staging the group
            diff = self._get_diff_for_files(files)
            if not diff.strip():
                self.logger.info(
                    f"[SKIP] No diff detected for group {group_name}. Unstaging files."
                )
                self._run_git_command(["git", "reset", "HEAD", "--", *files])
                continue

            commit_message = self._get_commit_message(group_name, diff, cached_messages)
            if not commit_message:
                self.logger.error(f"Skipping group {group_name} due to empty message.")
                self._run_git_command(["git", "reset", "HEAD", "--", *files])
                continue

            if self.dry_run:
                self._write_dry_run_entry(group_name, commit_message)
                # Unstage after processing for dry run
                self._run_git_command(["git", "reset", "HEAD", "--", *files])
            else:
                self._commit_changes(commit_message)

        if self.push and not self.dry_run:
            self._push_changes()

        self.logger.info("✅ Commit process completed.")

    def _get_commit_message(
        self, group_name: str, diff: str, cached_messages: dict
    ) -> str:
        """Gets a commit message either from cache or by generating it via AI."""
        if not self.force_rebuild and group_name in cached_messages:
            self.logger.info(f"[CACHED] Using cached message for {group_name}.")
            return cached_messages[group_name]

        if self.force_rebuild and group_name in cached_messages:
            self.logger.info(f"[FORCED] Ignoring cache for {group_name}.")

        template = self.commit_template_env.get_template("commit_message.j2")
        prompt = template.render(group_name=group_name, diff_text=diff)
        raw_message = generate_with_ai(
            prompt,
            provider=self.provider,
            model=self.model,
            debug=self.debug,
            **self.kwargs,
        )
        return clean_ai_response(raw_message)


def run_commit_group_all(**kwargs):
    """Initializes and runs the CommitGenerator."""
    try:
        generator = CommitGenerator(**kwargs)
        generator.run()
    except (CommitError, Exception) as e:
        logger = setup_logging("log/commit.log")
        logger.error(f"FATAL: The commit process failed: {e}", exc_info=True)


__all__ = ["run_commit_group_all"]
